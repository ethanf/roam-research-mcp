/* tslint:disable */
/* eslint-disable */
/**
 * Roam Research Tools API
 * API for interacting with Roam Research tools
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration.js';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common.js';
import type { RequestArgs } from './base.js';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base.js';

/**
 * 
 * @export
 * @interface Tool
 */
export interface Tool {
    /**
     * 
     * @type {string}
     * @memberof Tool
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tool
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Tool
     */
    'parameters'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ToolsGet200Response
 */
export interface ToolsGet200Response {
    /**
     * 
     * @type {Array<Tool>}
     * @memberof ToolsGet200Response
     */
    'tools'?: Array<Tool>;
}
/**
 * 
 * @export
 * @interface ToolsroamAddTodoPost200Response
 */
export interface ToolsroamAddTodoPost200Response {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ToolsroamAddTodoPost200Response
     */
    'data'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ToolsroamAddTodoPostRequest
 */
export interface ToolsroamAddTodoPostRequest {
    /**
     * List of todo items to add
     * @type {Array<string>}
     * @memberof ToolsroamAddTodoPostRequest
     */
    'todos': Array<string>;
}
/**
 * 
 * @export
 * @interface ToolsroamCreateBlockPostRequest
 */
export interface ToolsroamCreateBlockPostRequest {
    /**
     * Content of the block
     * @type {string}
     * @memberof ToolsroamCreateBlockPostRequest
     */
    'content': string;
    /**
     * Optional: UID of the page to add block to
     * @type {string}
     * @memberof ToolsroamCreateBlockPostRequest
     */
    'page_uid'?: string;
    /**
     * Optional: Title of the page to add block to (defaults to today\'s date if neither page_uid nor title provided)
     * @type {string}
     * @memberof ToolsroamCreateBlockPostRequest
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface ToolsroamCreateOutlinePostRequest
 */
export interface ToolsroamCreateOutlinePostRequest {
    /**
     * Title (or UID if known) of the page. Leave blank to use the default daily page
     * @type {string}
     * @memberof ToolsroamCreateOutlinePostRequest
     */
    'page_title_uid'?: string;
    /**
     * A relevant title heading for the outline (or UID, if known) of the block under which outline content will be nested. If blank, content will be nested under the page title.
     * @type {string}
     * @memberof ToolsroamCreateOutlinePostRequest
     */
    'block_text_uid'?: string;
    /**
     * Array of outline items with block text and explicit nesting level
     * @type {Array<ToolsroamCreateOutlinePostRequestOutlineInner>}
     * @memberof ToolsroamCreateOutlinePostRequest
     */
    'outline': Array<ToolsroamCreateOutlinePostRequestOutlineInner>;
}
/**
 * 
 * @export
 * @interface ToolsroamCreateOutlinePostRequestOutlineInner
 */
export interface ToolsroamCreateOutlinePostRequestOutlineInner {
    /**
     * Content of the block
     * @type {string}
     * @memberof ToolsroamCreateOutlinePostRequestOutlineInner
     */
    'text': string;
    /**
     * Indentation level (1-10, where 1 is top level)
     * @type {number}
     * @memberof ToolsroamCreateOutlinePostRequestOutlineInner
     */
    'level': number;
}
/**
 * 
 * @export
 * @interface ToolsroamCreatePagePostRequest
 */
export interface ToolsroamCreatePagePostRequest {
    /**
     * Title of the new page
     * @type {string}
     * @memberof ToolsroamCreatePagePostRequest
     */
    'title': string;
    /**
     * Initial content for the page (optional). Each line becomes a separate block. Indentation (using spaces or tabs) determines the nesting level of each block.
     * @type {string}
     * @memberof ToolsroamCreatePagePostRequest
     */
    'content'?: string;
}
/**
 * 
 * @export
 * @interface ToolsroamDatomicQueryPostRequest
 */
export interface ToolsroamDatomicQueryPostRequest {
    /**
     * The Datomic query to execute (in Datalog syntax)
     * @type {string}
     * @memberof ToolsroamDatomicQueryPostRequest
     */
    'query': string;
    /**
     * Optional array of input parameters for the query
     * @type {Array<string>}
     * @memberof ToolsroamDatomicQueryPostRequest
     */
    'inputs'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ToolsroamFetchPageByTitlePostRequest
 */
export interface ToolsroamFetchPageByTitlePostRequest {
    /**
     * Title of the page to fetch and read
     * @type {string}
     * @memberof ToolsroamFetchPageByTitlePostRequest
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface ToolsroamImportMarkdownPostRequest
 */
export interface ToolsroamImportMarkdownPostRequest {
    /**
     * Nested markdown content to import
     * @type {string}
     * @memberof ToolsroamImportMarkdownPostRequest
     */
    'content': string;
    /**
     * Optional: UID of the page containing the parent block
     * @type {string}
     * @memberof ToolsroamImportMarkdownPostRequest
     */
    'page_uid'?: string;
    /**
     * Optional: Title of the page containing the parent block (ignored if page_uid provided)
     * @type {string}
     * @memberof ToolsroamImportMarkdownPostRequest
     */
    'page_title'?: string;
    /**
     * Optional: UID of the parent block to add content under
     * @type {string}
     * @memberof ToolsroamImportMarkdownPostRequest
     */
    'parent_uid'?: string;
    /**
     * Optional: Exact string content of the parent block to add content under (must provide either page_uid or page_title)
     * @type {string}
     * @memberof ToolsroamImportMarkdownPostRequest
     */
    'parent_string'?: string;
    /**
     * Optional: Where to add the content under the parent (\"first\" or \"last\")
     * @type {string}
     * @memberof ToolsroamImportMarkdownPostRequest
     */
    'order'?: ToolsroamImportMarkdownPostRequestOrderEnum;
}

export const ToolsroamImportMarkdownPostRequestOrderEnum = {
    First: 'first',
    Last: 'last'
} as const;

export type ToolsroamImportMarkdownPostRequestOrderEnum = typeof ToolsroamImportMarkdownPostRequestOrderEnum[keyof typeof ToolsroamImportMarkdownPostRequestOrderEnum];

/**
 * 
 * @export
 * @interface ToolsroamRememberPostRequest
 */
export interface ToolsroamRememberPostRequest {
    /**
     * The memory or information to remember
     * @type {string}
     * @memberof ToolsroamRememberPostRequest
     */
    'memory': string;
    /**
     * Optional categories to tag the memory with (will be converted to Roam tags)
     * @type {Array<string>}
     * @memberof ToolsroamRememberPostRequest
     */
    'categories'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ToolsroamSearchBlockRefsPostRequest
 */
export interface ToolsroamSearchBlockRefsPostRequest {
    /**
     * Optional: UID of the block to find references to
     * @type {string}
     * @memberof ToolsroamSearchBlockRefsPostRequest
     */
    'block_uid'?: string;
    /**
     * Optional: Title or UID of the page to search in. If not provided, searches across all pages
     * @type {string}
     * @memberof ToolsroamSearchBlockRefsPostRequest
     */
    'page_title_uid'?: string;
}
/**
 * 
 * @export
 * @interface ToolsroamSearchByDatePostRequest
 */
export interface ToolsroamSearchByDatePostRequest {
    /**
     * Start date in ISO format (YYYY-MM-DD)
     * @type {string}
     * @memberof ToolsroamSearchByDatePostRequest
     */
    'start_date': string;
    /**
     * Optional: End date in ISO format (YYYY-MM-DD)
     * @type {string}
     * @memberof ToolsroamSearchByDatePostRequest
     */
    'end_date'?: string;
    /**
     * Whether to search by creation date, modification date, or both
     * @type {string}
     * @memberof ToolsroamSearchByDatePostRequest
     */
    'type': ToolsroamSearchByDatePostRequestTypeEnum;
    /**
     * Whether to search blocks, pages, or both
     * @type {string}
     * @memberof ToolsroamSearchByDatePostRequest
     */
    'scope': ToolsroamSearchByDatePostRequestScopeEnum;
    /**
     * Whether to include the content of matching blocks/pages
     * @type {boolean}
     * @memberof ToolsroamSearchByDatePostRequest
     */
    'include_content'?: boolean;
}

export const ToolsroamSearchByDatePostRequestTypeEnum = {
    Created: 'created',
    Modified: 'modified',
    Both: 'both'
} as const;

export type ToolsroamSearchByDatePostRequestTypeEnum = typeof ToolsroamSearchByDatePostRequestTypeEnum[keyof typeof ToolsroamSearchByDatePostRequestTypeEnum];
export const ToolsroamSearchByDatePostRequestScopeEnum = {
    Blocks: 'blocks',
    Pages: 'pages',
    Both: 'both'
} as const;

export type ToolsroamSearchByDatePostRequestScopeEnum = typeof ToolsroamSearchByDatePostRequestScopeEnum[keyof typeof ToolsroamSearchByDatePostRequestScopeEnum];

/**
 * 
 * @export
 * @interface ToolsroamSearchByStatusPostRequest
 */
export interface ToolsroamSearchByStatusPostRequest {
    /**
     * Status to search for (TODO or DONE)
     * @type {string}
     * @memberof ToolsroamSearchByStatusPostRequest
     */
    'status': ToolsroamSearchByStatusPostRequestStatusEnum;
    /**
     * Optional: Title or UID of the page to search in. If not provided, searches across all pages
     * @type {string}
     * @memberof ToolsroamSearchByStatusPostRequest
     */
    'page_title_uid'?: string;
    /**
     * Optional: Comma-separated list of terms to filter results by inclusion (matches content or page title)
     * @type {string}
     * @memberof ToolsroamSearchByStatusPostRequest
     */
    'include'?: string;
    /**
     * Optional: Comma-separated list of terms to filter results by exclusion (matches content or page title)
     * @type {string}
     * @memberof ToolsroamSearchByStatusPostRequest
     */
    'exclude'?: string;
}

export const ToolsroamSearchByStatusPostRequestStatusEnum = {
    Todo: 'TODO',
    Done: 'DONE'
} as const;

export type ToolsroamSearchByStatusPostRequestStatusEnum = typeof ToolsroamSearchByStatusPostRequestStatusEnum[keyof typeof ToolsroamSearchByStatusPostRequestStatusEnum];

/**
 * 
 * @export
 * @interface ToolsroamSearchByTextPostRequest
 */
export interface ToolsroamSearchByTextPostRequest {
    /**
     * The text to search for
     * @type {string}
     * @memberof ToolsroamSearchByTextPostRequest
     */
    'text': string;
    /**
     * Optional: Title or UID of the page to search in. If not provided, searches across all pages
     * @type {string}
     * @memberof ToolsroamSearchByTextPostRequest
     */
    'page_title_uid'?: string;
}
/**
 * 
 * @export
 * @interface ToolsroamSearchForTagPostRequest
 */
export interface ToolsroamSearchForTagPostRequest {
    /**
     * The main tag to search for (without the [[ ]] brackets)
     * @type {string}
     * @memberof ToolsroamSearchForTagPostRequest
     */
    'primary_tag': string;
    /**
     * Optional: Title or UID of the page to search in. Defaults to today\'s daily page if not provided
     * @type {string}
     * @memberof ToolsroamSearchForTagPostRequest
     */
    'page_title_uid'?: string;
    /**
     * Optional: Another tag to filter results by - will only return blocks where both tags appear
     * @type {string}
     * @memberof ToolsroamSearchForTagPostRequest
     */
    'near_tag'?: string;
}
/**
 * 
 * @export
 * @interface ToolsroamSearchHierarchyPostRequest
 */
export interface ToolsroamSearchHierarchyPostRequest {
    /**
     * Optional: UID of the block to find children of
     * @type {string}
     * @memberof ToolsroamSearchHierarchyPostRequest
     */
    'parent_uid'?: string;
    /**
     * Optional: UID of the block to find parents of
     * @type {string}
     * @memberof ToolsroamSearchHierarchyPostRequest
     */
    'child_uid'?: string;
    /**
     * Optional: Title or UID of the page to search in
     * @type {string}
     * @memberof ToolsroamSearchHierarchyPostRequest
     */
    'page_title_uid'?: string;
    /**
     * Optional: How many levels deep to search (default: 1)
     * @type {number}
     * @memberof ToolsroamSearchHierarchyPostRequest
     */
    'max_depth'?: number;
}
/**
 * 
 * @export
 * @interface ToolsroamUpdateBlockPostRequest
 */
export interface ToolsroamUpdateBlockPostRequest {
    /**
     * UID of the block to update
     * @type {string}
     * @memberof ToolsroamUpdateBlockPostRequest
     */
    'block_uid': string;
    /**
     * New content for the block. If not provided, transform_pattern will be used.
     * @type {string}
     * @memberof ToolsroamUpdateBlockPostRequest
     */
    'content'?: string;
    /**
     * 
     * @type {ToolsroamUpdateBlockPostRequestTransformPattern}
     * @memberof ToolsroamUpdateBlockPostRequest
     */
    'transform_pattern'?: ToolsroamUpdateBlockPostRequestTransformPattern;
}
/**
 * Pattern to transform the current content. Used if content is not provided.
 * @export
 * @interface ToolsroamUpdateBlockPostRequestTransformPattern
 */
export interface ToolsroamUpdateBlockPostRequestTransformPattern {
    /**
     * Text or regex pattern to find
     * @type {string}
     * @memberof ToolsroamUpdateBlockPostRequestTransformPattern
     */
    'find': string;
    /**
     * Text to replace with
     * @type {string}
     * @memberof ToolsroamUpdateBlockPostRequestTransformPattern
     */
    'replace': string;
    /**
     * Whether to replace all occurrences
     * @type {boolean}
     * @memberof ToolsroamUpdateBlockPostRequestTransformPattern
     */
    'global'?: boolean;
}
/**
 * 
 * @export
 * @interface ToolsroamUpdateBlocksPostRequest
 */
export interface ToolsroamUpdateBlocksPostRequest {
    /**
     * Array of block updates to perform
     * @type {Array<ToolsroamUpdateBlocksPostRequestUpdatesInner>}
     * @memberof ToolsroamUpdateBlocksPostRequest
     */
    'updates': Array<ToolsroamUpdateBlocksPostRequestUpdatesInner>;
}
/**
 * 
 * @export
 * @interface ToolsroamUpdateBlocksPostRequestUpdatesInner
 */
export interface ToolsroamUpdateBlocksPostRequestUpdatesInner {
    /**
     * UID of the block to update
     * @type {string}
     * @memberof ToolsroamUpdateBlocksPostRequestUpdatesInner
     */
    'block_uid': string;
    /**
     * New content for the block. If not provided, transform will be used.
     * @type {string}
     * @memberof ToolsroamUpdateBlocksPostRequestUpdatesInner
     */
    'content'?: string;
    /**
     * 
     * @type {ToolsroamUpdateBlockPostRequestTransformPattern}
     * @memberof ToolsroamUpdateBlocksPostRequestUpdatesInner
     */
    'transform'?: ToolsroamUpdateBlockPostRequestTransformPattern;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all available tools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all pages that have been modified today (since midnight).
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsfindPagesModifiedTodayPost: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('toolsfindPagesModifiedTodayPost', 'body', body)
            const localVarPath = `/tools/find_pages_modified_today`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a list of todo items as individual blocks to today\'s daily page in Roam. Each item becomes its own actionable block with todo status. NOTE on Roam-flavored markdown: For direct linking: use [[link]] syntax. For aliased linking, use [alias]([[link]]) syntax. Do not concatenate words in links/hashtags - correct: #[[multiple words]] #self-esteem (for typically hyphenated words).
         * @param {ToolsroamAddTodoPostRequest} toolsroamAddTodoPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamAddTodoPost: async (toolsroamAddTodoPostRequest: ToolsroamAddTodoPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toolsroamAddTodoPostRequest' is not null or undefined
            assertParamExists('toolsroamAddTodoPost', 'toolsroamAddTodoPostRequest', toolsroamAddTodoPostRequest)
            const localVarPath = `/tools/roam_add_todo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(toolsroamAddTodoPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new block to an existing Roam page. If no page specified, adds to today\'s daily note. Best for capturing immediate thoughts, additions to discussions, or content that doesn\'t warrant its own page. Can specify page by title or UID. NOTE on Roam-flavored markdown: For direct linking: use [[link]] syntax. For aliased linking, use [alias]([[link]]) syntax. Do not concatenate words in links/hashtags - correct: #[[multiple words]] #self-esteem (for typically hyphenated words).
         * @param {ToolsroamCreateBlockPostRequest} toolsroamCreateBlockPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamCreateBlockPost: async (toolsroamCreateBlockPostRequest: ToolsroamCreateBlockPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toolsroamCreateBlockPostRequest' is not null or undefined
            assertParamExists('toolsroamCreateBlockPost', 'toolsroamCreateBlockPostRequest', toolsroamCreateBlockPostRequest)
            const localVarPath = `/tools/roam_create_block`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(toolsroamCreateBlockPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a structured outline to an existing page or block (by title text or uid), with customizable nesting levels. Best for: - Adding supplementary structured content to existing pages - Creating temporary or working outlines (meeting notes, brainstorms) - Organizing thoughts or research under a specific topic - Breaking down subtopics or components of a larger concept
         * @param {ToolsroamCreateOutlinePostRequest} toolsroamCreateOutlinePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamCreateOutlinePost: async (toolsroamCreateOutlinePostRequest: ToolsroamCreateOutlinePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toolsroamCreateOutlinePostRequest' is not null or undefined
            assertParamExists('toolsroamCreateOutlinePost', 'toolsroamCreateOutlinePostRequest', toolsroamCreateOutlinePostRequest)
            const localVarPath = `/tools/roam_create_outline`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(toolsroamCreateOutlinePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new standalone page in Roam with optional content using markdown-style formatting. The nesting structure is inferred from markdown indentation (spaces). Best for: - Creating foundational concept pages that other pages will link to/from - Establishing new topic areas that need their own namespace - Setting up reference materials or documentation - Making permanent collections of information.
         * @param {ToolsroamCreatePagePostRequest} toolsroamCreatePagePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamCreatePagePost: async (toolsroamCreatePagePostRequest: ToolsroamCreatePagePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toolsroamCreatePagePostRequest' is not null or undefined
            assertParamExists('toolsroamCreatePagePost', 'toolsroamCreatePagePostRequest', toolsroamCreatePagePostRequest)
            const localVarPath = `/tools/roam_create_page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(toolsroamCreatePagePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Execute a custom Datomic query on the Roam graph beyond the available search tools. This provides direct access to Roam\'s query engine for advanced data retrieval. Note: Roam graph is case-sensitive. List of some of Roam\'s data model Namespaces and Attributes: ancestor (descendants), attrs (lookup), block (children, heading, open, order, page, parents, props, refs, string, text-align, uid), children (view-type), create (email, time), descendant (ancestors), edit (email, seen-by, time), entity (attrs), log (id), node (title), page (uid, title), refs (text). Predicates (clojure.string/includes?, clojure.string/starts-with?, clojure.string/ends-with?, <, >, <=, >=, =, not=, !=). Aggregates (distinct, count, sum, max, min, avg, limit). Tips: Use :block/parents for all ancestor levels, :block/children for direct descendants only; combine clojure.string for complex matching, use distinct to deduplicate, leverage Pull patterns for hierarchies, handle case-sensitivity carefully, and chain ancestry rules for multi-level queries.
         * @param {ToolsroamDatomicQueryPostRequest} toolsroamDatomicQueryPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamDatomicQueryPost: async (toolsroamDatomicQueryPostRequest: ToolsroamDatomicQueryPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toolsroamDatomicQueryPostRequest' is not null or undefined
            assertParamExists('toolsroamDatomicQueryPost', 'toolsroamDatomicQueryPostRequest', toolsroamDatomicQueryPostRequest)
            const localVarPath = `/tools/roam_datomic_query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(toolsroamDatomicQueryPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve complete page contents by exact title, including all nested blocks and resolved block references. Use for reading and analyzing existing Roam pages.
         * @param {ToolsroamFetchPageByTitlePostRequest} toolsroamFetchPageByTitlePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamFetchPageByTitlePost: async (toolsroamFetchPageByTitlePostRequest: ToolsroamFetchPageByTitlePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toolsroamFetchPageByTitlePostRequest' is not null or undefined
            assertParamExists('toolsroamFetchPageByTitlePost', 'toolsroamFetchPageByTitlePostRequest', toolsroamFetchPageByTitlePostRequest)
            const localVarPath = `/tools/roam_fetch_page_by_title`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(toolsroamFetchPageByTitlePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import nested markdown content into Roam under a specific block. Can locate the parent block by UID or by exact string match within a specific page.
         * @param {ToolsroamImportMarkdownPostRequest} toolsroamImportMarkdownPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamImportMarkdownPost: async (toolsroamImportMarkdownPostRequest: ToolsroamImportMarkdownPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toolsroamImportMarkdownPostRequest' is not null or undefined
            assertParamExists('toolsroamImportMarkdownPost', 'toolsroamImportMarkdownPostRequest', toolsroamImportMarkdownPostRequest)
            const localVarPath = `/tools/roam_import_markdown`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(toolsroamImportMarkdownPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve all stored memories by searching for blocks tagged with MEMORIES_TAG and content from the page with the same name. Returns a combined, deduplicated list of memories.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamRecallPost: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('toolsroamRecallPost', 'body', body)
            const localVarPath = `/tools/roam_recall`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a memory or piece of information to remember, stored on the daily page with #[[LLM/Memories]] tag and optional categories.  NOTE on Roam-flavored markdown: For direct linking: use [[link]] syntax. For aliased linking, use [alias]([[link]]) syntax. Do not concatenate words in links/hashtags - correct: #[[multiple words]] #self-esteem (for typically hyphenated words).
         * @param {ToolsroamRememberPostRequest} toolsroamRememberPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamRememberPost: async (toolsroamRememberPostRequest: ToolsroamRememberPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toolsroamRememberPostRequest' is not null or undefined
            assertParamExists('toolsroamRememberPost', 'toolsroamRememberPostRequest', toolsroamRememberPostRequest)
            const localVarPath = `/tools/roam_remember`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(toolsroamRememberPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for block references within a page or across the entire graph. Can search for references to a specific block or find all block references.
         * @param {ToolsroamSearchBlockRefsPostRequest} toolsroamSearchBlockRefsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamSearchBlockRefsPost: async (toolsroamSearchBlockRefsPostRequest: ToolsroamSearchBlockRefsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toolsroamSearchBlockRefsPostRequest' is not null or undefined
            assertParamExists('toolsroamSearchBlockRefsPost', 'toolsroamSearchBlockRefsPostRequest', toolsroamSearchBlockRefsPostRequest)
            const localVarPath = `/tools/roam_search_block_refs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(toolsroamSearchBlockRefsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for blocks or pages based on creation or modification dates
         * @param {ToolsroamSearchByDatePostRequest} toolsroamSearchByDatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamSearchByDatePost: async (toolsroamSearchByDatePostRequest: ToolsroamSearchByDatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toolsroamSearchByDatePostRequest' is not null or undefined
            assertParamExists('toolsroamSearchByDatePost', 'toolsroamSearchByDatePostRequest', toolsroamSearchByDatePostRequest)
            const localVarPath = `/tools/roam_search_by_date`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(toolsroamSearchByDatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for blocks with a specific status (TODO/DONE) across all pages or within a specific page.
         * @param {ToolsroamSearchByStatusPostRequest} toolsroamSearchByStatusPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamSearchByStatusPost: async (toolsroamSearchByStatusPostRequest: ToolsroamSearchByStatusPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toolsroamSearchByStatusPostRequest' is not null or undefined
            assertParamExists('toolsroamSearchByStatusPost', 'toolsroamSearchByStatusPostRequest', toolsroamSearchByStatusPostRequest)
            const localVarPath = `/tools/roam_search_by_status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(toolsroamSearchByStatusPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for blocks containing specific text across all pages or within a specific page.
         * @param {ToolsroamSearchByTextPostRequest} toolsroamSearchByTextPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamSearchByTextPost: async (toolsroamSearchByTextPostRequest: ToolsroamSearchByTextPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toolsroamSearchByTextPostRequest' is not null or undefined
            assertParamExists('toolsroamSearchByTextPost', 'toolsroamSearchByTextPostRequest', toolsroamSearchByTextPostRequest)
            const localVarPath = `/tools/roam_search_by_text`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(toolsroamSearchByTextPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for blocks containing a specific tag and optionally filter by blocks that also contain another tag nearby. Example: Use this to search for memories that are tagged with the MEMORIES_TAG.
         * @param {ToolsroamSearchForTagPostRequest} toolsroamSearchForTagPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamSearchForTagPost: async (toolsroamSearchForTagPostRequest: ToolsroamSearchForTagPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toolsroamSearchForTagPostRequest' is not null or undefined
            assertParamExists('toolsroamSearchForTagPost', 'toolsroamSearchForTagPostRequest', toolsroamSearchForTagPostRequest)
            const localVarPath = `/tools/roam_search_for_tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(toolsroamSearchForTagPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for parent or child blocks in the block hierarchy. Can search up or down the hierarchy from a given block.
         * @param {ToolsroamSearchHierarchyPostRequest | null} toolsroamSearchHierarchyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamSearchHierarchyPost: async (toolsroamSearchHierarchyPostRequest: ToolsroamSearchHierarchyPostRequest | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toolsroamSearchHierarchyPostRequest' is not null or undefined
            assertParamExists('toolsroamSearchHierarchyPost', 'toolsroamSearchHierarchyPostRequest', toolsroamSearchHierarchyPostRequest)
            const localVarPath = `/tools/roam_search_hierarchy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(toolsroamSearchHierarchyPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the content of an existing block identified by its UID. Can either provide new content directly or use a transform pattern to modify existing content. NOTE on Roam-flavored markdown: For direct linking: use [[link]] syntax. For aliased linking, use [alias]([[link]]) syntax. Do not concatenate words in links/hashtags - correct: #[[multiple words]] #self-esteem (for typically hyphenated words).
         * @param {ToolsroamUpdateBlockPostRequest | null} toolsroamUpdateBlockPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamUpdateBlockPost: async (toolsroamUpdateBlockPostRequest: ToolsroamUpdateBlockPostRequest | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toolsroamUpdateBlockPostRequest' is not null or undefined
            assertParamExists('toolsroamUpdateBlockPost', 'toolsroamUpdateBlockPostRequest', toolsroamUpdateBlockPostRequest)
            const localVarPath = `/tools/roam_update_block`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(toolsroamUpdateBlockPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update multiple blocks in a single batch operation. Each update can provide either new content directly or a transform pattern. NOTE on Roam-flavored markdown: For direct linking: use [[link]] syntax. For aliased linking, use [alias]([[link]]) syntax. Do not concatenate words in links/hashtags - correct: #[[multiple words]] #self-esteem (for typically hyphenated words).
         * @param {ToolsroamUpdateBlocksPostRequest} toolsroamUpdateBlocksPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamUpdateBlocksPost: async (toolsroamUpdateBlocksPostRequest: ToolsroamUpdateBlocksPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toolsroamUpdateBlocksPostRequest' is not null or undefined
            assertParamExists('toolsroamUpdateBlocksPost', 'toolsroamUpdateBlocksPostRequest', toolsroamUpdateBlocksPostRequest)
            const localVarPath = `/tools/roam_update_blocks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(toolsroamUpdateBlocksPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all available tools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.toolsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Find all pages that have been modified today (since midnight).
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolsfindPagesModifiedTodayPost(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolsroamAddTodoPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolsfindPagesModifiedTodayPost(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.toolsfindPagesModifiedTodayPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add a list of todo items as individual blocks to today\'s daily page in Roam. Each item becomes its own actionable block with todo status. NOTE on Roam-flavored markdown: For direct linking: use [[link]] syntax. For aliased linking, use [alias]([[link]]) syntax. Do not concatenate words in links/hashtags - correct: #[[multiple words]] #self-esteem (for typically hyphenated words).
         * @param {ToolsroamAddTodoPostRequest} toolsroamAddTodoPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolsroamAddTodoPost(toolsroamAddTodoPostRequest: ToolsroamAddTodoPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolsroamAddTodoPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolsroamAddTodoPost(toolsroamAddTodoPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.toolsroamAddTodoPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add a new block to an existing Roam page. If no page specified, adds to today\'s daily note. Best for capturing immediate thoughts, additions to discussions, or content that doesn\'t warrant its own page. Can specify page by title or UID. NOTE on Roam-flavored markdown: For direct linking: use [[link]] syntax. For aliased linking, use [alias]([[link]]) syntax. Do not concatenate words in links/hashtags - correct: #[[multiple words]] #self-esteem (for typically hyphenated words).
         * @param {ToolsroamCreateBlockPostRequest} toolsroamCreateBlockPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolsroamCreateBlockPost(toolsroamCreateBlockPostRequest: ToolsroamCreateBlockPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolsroamAddTodoPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolsroamCreateBlockPost(toolsroamCreateBlockPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.toolsroamCreateBlockPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add a structured outline to an existing page or block (by title text or uid), with customizable nesting levels. Best for: - Adding supplementary structured content to existing pages - Creating temporary or working outlines (meeting notes, brainstorms) - Organizing thoughts or research under a specific topic - Breaking down subtopics or components of a larger concept
         * @param {ToolsroamCreateOutlinePostRequest} toolsroamCreateOutlinePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolsroamCreateOutlinePost(toolsroamCreateOutlinePostRequest: ToolsroamCreateOutlinePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolsroamAddTodoPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolsroamCreateOutlinePost(toolsroamCreateOutlinePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.toolsroamCreateOutlinePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new standalone page in Roam with optional content using markdown-style formatting. The nesting structure is inferred from markdown indentation (spaces). Best for: - Creating foundational concept pages that other pages will link to/from - Establishing new topic areas that need their own namespace - Setting up reference materials or documentation - Making permanent collections of information.
         * @param {ToolsroamCreatePagePostRequest} toolsroamCreatePagePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolsroamCreatePagePost(toolsroamCreatePagePostRequest: ToolsroamCreatePagePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolsroamAddTodoPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolsroamCreatePagePost(toolsroamCreatePagePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.toolsroamCreatePagePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Execute a custom Datomic query on the Roam graph beyond the available search tools. This provides direct access to Roam\'s query engine for advanced data retrieval. Note: Roam graph is case-sensitive. List of some of Roam\'s data model Namespaces and Attributes: ancestor (descendants), attrs (lookup), block (children, heading, open, order, page, parents, props, refs, string, text-align, uid), children (view-type), create (email, time), descendant (ancestors), edit (email, seen-by, time), entity (attrs), log (id), node (title), page (uid, title), refs (text). Predicates (clojure.string/includes?, clojure.string/starts-with?, clojure.string/ends-with?, <, >, <=, >=, =, not=, !=). Aggregates (distinct, count, sum, max, min, avg, limit). Tips: Use :block/parents for all ancestor levels, :block/children for direct descendants only; combine clojure.string for complex matching, use distinct to deduplicate, leverage Pull patterns for hierarchies, handle case-sensitivity carefully, and chain ancestry rules for multi-level queries.
         * @param {ToolsroamDatomicQueryPostRequest} toolsroamDatomicQueryPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolsroamDatomicQueryPost(toolsroamDatomicQueryPostRequest: ToolsroamDatomicQueryPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolsroamAddTodoPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolsroamDatomicQueryPost(toolsroamDatomicQueryPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.toolsroamDatomicQueryPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve complete page contents by exact title, including all nested blocks and resolved block references. Use for reading and analyzing existing Roam pages.
         * @param {ToolsroamFetchPageByTitlePostRequest} toolsroamFetchPageByTitlePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolsroamFetchPageByTitlePost(toolsroamFetchPageByTitlePostRequest: ToolsroamFetchPageByTitlePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolsroamAddTodoPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolsroamFetchPageByTitlePost(toolsroamFetchPageByTitlePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.toolsroamFetchPageByTitlePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Import nested markdown content into Roam under a specific block. Can locate the parent block by UID or by exact string match within a specific page.
         * @param {ToolsroamImportMarkdownPostRequest} toolsroamImportMarkdownPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolsroamImportMarkdownPost(toolsroamImportMarkdownPostRequest: ToolsroamImportMarkdownPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolsroamAddTodoPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolsroamImportMarkdownPost(toolsroamImportMarkdownPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.toolsroamImportMarkdownPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve all stored memories by searching for blocks tagged with MEMORIES_TAG and content from the page with the same name. Returns a combined, deduplicated list of memories.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolsroamRecallPost(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolsroamAddTodoPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolsroamRecallPost(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.toolsroamRecallPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add a memory or piece of information to remember, stored on the daily page with #[[LLM/Memories]] tag and optional categories.  NOTE on Roam-flavored markdown: For direct linking: use [[link]] syntax. For aliased linking, use [alias]([[link]]) syntax. Do not concatenate words in links/hashtags - correct: #[[multiple words]] #self-esteem (for typically hyphenated words).
         * @param {ToolsroamRememberPostRequest} toolsroamRememberPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolsroamRememberPost(toolsroamRememberPostRequest: ToolsroamRememberPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolsroamAddTodoPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolsroamRememberPost(toolsroamRememberPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.toolsroamRememberPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search for block references within a page or across the entire graph. Can search for references to a specific block or find all block references.
         * @param {ToolsroamSearchBlockRefsPostRequest} toolsroamSearchBlockRefsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolsroamSearchBlockRefsPost(toolsroamSearchBlockRefsPostRequest: ToolsroamSearchBlockRefsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolsroamAddTodoPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolsroamSearchBlockRefsPost(toolsroamSearchBlockRefsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.toolsroamSearchBlockRefsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search for blocks or pages based on creation or modification dates
         * @param {ToolsroamSearchByDatePostRequest} toolsroamSearchByDatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolsroamSearchByDatePost(toolsroamSearchByDatePostRequest: ToolsroamSearchByDatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolsroamAddTodoPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolsroamSearchByDatePost(toolsroamSearchByDatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.toolsroamSearchByDatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search for blocks with a specific status (TODO/DONE) across all pages or within a specific page.
         * @param {ToolsroamSearchByStatusPostRequest} toolsroamSearchByStatusPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolsroamSearchByStatusPost(toolsroamSearchByStatusPostRequest: ToolsroamSearchByStatusPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolsroamAddTodoPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolsroamSearchByStatusPost(toolsroamSearchByStatusPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.toolsroamSearchByStatusPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search for blocks containing specific text across all pages or within a specific page.
         * @param {ToolsroamSearchByTextPostRequest} toolsroamSearchByTextPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolsroamSearchByTextPost(toolsroamSearchByTextPostRequest: ToolsroamSearchByTextPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolsroamAddTodoPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolsroamSearchByTextPost(toolsroamSearchByTextPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.toolsroamSearchByTextPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search for blocks containing a specific tag and optionally filter by blocks that also contain another tag nearby. Example: Use this to search for memories that are tagged with the MEMORIES_TAG.
         * @param {ToolsroamSearchForTagPostRequest} toolsroamSearchForTagPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolsroamSearchForTagPost(toolsroamSearchForTagPostRequest: ToolsroamSearchForTagPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolsroamAddTodoPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolsroamSearchForTagPost(toolsroamSearchForTagPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.toolsroamSearchForTagPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search for parent or child blocks in the block hierarchy. Can search up or down the hierarchy from a given block.
         * @param {ToolsroamSearchHierarchyPostRequest | null} toolsroamSearchHierarchyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolsroamSearchHierarchyPost(toolsroamSearchHierarchyPostRequest: ToolsroamSearchHierarchyPostRequest | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolsroamAddTodoPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolsroamSearchHierarchyPost(toolsroamSearchHierarchyPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.toolsroamSearchHierarchyPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the content of an existing block identified by its UID. Can either provide new content directly or use a transform pattern to modify existing content. NOTE on Roam-flavored markdown: For direct linking: use [[link]] syntax. For aliased linking, use [alias]([[link]]) syntax. Do not concatenate words in links/hashtags - correct: #[[multiple words]] #self-esteem (for typically hyphenated words).
         * @param {ToolsroamUpdateBlockPostRequest | null} toolsroamUpdateBlockPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolsroamUpdateBlockPost(toolsroamUpdateBlockPostRequest: ToolsroamUpdateBlockPostRequest | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolsroamAddTodoPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolsroamUpdateBlockPost(toolsroamUpdateBlockPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.toolsroamUpdateBlockPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update multiple blocks in a single batch operation. Each update can provide either new content directly or a transform pattern. NOTE on Roam-flavored markdown: For direct linking: use [[link]] syntax. For aliased linking, use [alias]([[link]]) syntax. Do not concatenate words in links/hashtags - correct: #[[multiple words]] #self-esteem (for typically hyphenated words).
         * @param {ToolsroamUpdateBlocksPostRequest} toolsroamUpdateBlocksPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolsroamUpdateBlocksPost(toolsroamUpdateBlocksPostRequest: ToolsroamUpdateBlocksPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolsroamAddTodoPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolsroamUpdateBlocksPost(toolsroamUpdateBlocksPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.toolsroamUpdateBlocksPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary List all available tools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsGet(options?: RawAxiosRequestConfig): AxiosPromise<ToolsGet200Response> {
            return localVarFp.toolsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find all pages that have been modified today (since midnight).
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsfindPagesModifiedTodayPost(body: object, options?: RawAxiosRequestConfig): AxiosPromise<ToolsroamAddTodoPost200Response> {
            return localVarFp.toolsfindPagesModifiedTodayPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a list of todo items as individual blocks to today\'s daily page in Roam. Each item becomes its own actionable block with todo status. NOTE on Roam-flavored markdown: For direct linking: use [[link]] syntax. For aliased linking, use [alias]([[link]]) syntax. Do not concatenate words in links/hashtags - correct: #[[multiple words]] #self-esteem (for typically hyphenated words).
         * @param {ToolsroamAddTodoPostRequest} toolsroamAddTodoPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamAddTodoPost(toolsroamAddTodoPostRequest: ToolsroamAddTodoPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolsroamAddTodoPost200Response> {
            return localVarFp.toolsroamAddTodoPost(toolsroamAddTodoPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new block to an existing Roam page. If no page specified, adds to today\'s daily note. Best for capturing immediate thoughts, additions to discussions, or content that doesn\'t warrant its own page. Can specify page by title or UID. NOTE on Roam-flavored markdown: For direct linking: use [[link]] syntax. For aliased linking, use [alias]([[link]]) syntax. Do not concatenate words in links/hashtags - correct: #[[multiple words]] #self-esteem (for typically hyphenated words).
         * @param {ToolsroamCreateBlockPostRequest} toolsroamCreateBlockPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamCreateBlockPost(toolsroamCreateBlockPostRequest: ToolsroamCreateBlockPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolsroamAddTodoPost200Response> {
            return localVarFp.toolsroamCreateBlockPost(toolsroamCreateBlockPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a structured outline to an existing page or block (by title text or uid), with customizable nesting levels. Best for: - Adding supplementary structured content to existing pages - Creating temporary or working outlines (meeting notes, brainstorms) - Organizing thoughts or research under a specific topic - Breaking down subtopics or components of a larger concept
         * @param {ToolsroamCreateOutlinePostRequest} toolsroamCreateOutlinePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamCreateOutlinePost(toolsroamCreateOutlinePostRequest: ToolsroamCreateOutlinePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolsroamAddTodoPost200Response> {
            return localVarFp.toolsroamCreateOutlinePost(toolsroamCreateOutlinePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new standalone page in Roam with optional content using markdown-style formatting. The nesting structure is inferred from markdown indentation (spaces). Best for: - Creating foundational concept pages that other pages will link to/from - Establishing new topic areas that need their own namespace - Setting up reference materials or documentation - Making permanent collections of information.
         * @param {ToolsroamCreatePagePostRequest} toolsroamCreatePagePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamCreatePagePost(toolsroamCreatePagePostRequest: ToolsroamCreatePagePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolsroamAddTodoPost200Response> {
            return localVarFp.toolsroamCreatePagePost(toolsroamCreatePagePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Execute a custom Datomic query on the Roam graph beyond the available search tools. This provides direct access to Roam\'s query engine for advanced data retrieval. Note: Roam graph is case-sensitive. List of some of Roam\'s data model Namespaces and Attributes: ancestor (descendants), attrs (lookup), block (children, heading, open, order, page, parents, props, refs, string, text-align, uid), children (view-type), create (email, time), descendant (ancestors), edit (email, seen-by, time), entity (attrs), log (id), node (title), page (uid, title), refs (text). Predicates (clojure.string/includes?, clojure.string/starts-with?, clojure.string/ends-with?, <, >, <=, >=, =, not=, !=). Aggregates (distinct, count, sum, max, min, avg, limit). Tips: Use :block/parents for all ancestor levels, :block/children for direct descendants only; combine clojure.string for complex matching, use distinct to deduplicate, leverage Pull patterns for hierarchies, handle case-sensitivity carefully, and chain ancestry rules for multi-level queries.
         * @param {ToolsroamDatomicQueryPostRequest} toolsroamDatomicQueryPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamDatomicQueryPost(toolsroamDatomicQueryPostRequest: ToolsroamDatomicQueryPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolsroamAddTodoPost200Response> {
            return localVarFp.toolsroamDatomicQueryPost(toolsroamDatomicQueryPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve complete page contents by exact title, including all nested blocks and resolved block references. Use for reading and analyzing existing Roam pages.
         * @param {ToolsroamFetchPageByTitlePostRequest} toolsroamFetchPageByTitlePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamFetchPageByTitlePost(toolsroamFetchPageByTitlePostRequest: ToolsroamFetchPageByTitlePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolsroamAddTodoPost200Response> {
            return localVarFp.toolsroamFetchPageByTitlePost(toolsroamFetchPageByTitlePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import nested markdown content into Roam under a specific block. Can locate the parent block by UID or by exact string match within a specific page.
         * @param {ToolsroamImportMarkdownPostRequest} toolsroamImportMarkdownPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamImportMarkdownPost(toolsroamImportMarkdownPostRequest: ToolsroamImportMarkdownPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolsroamAddTodoPost200Response> {
            return localVarFp.toolsroamImportMarkdownPost(toolsroamImportMarkdownPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve all stored memories by searching for blocks tagged with MEMORIES_TAG and content from the page with the same name. Returns a combined, deduplicated list of memories.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamRecallPost(body: object, options?: RawAxiosRequestConfig): AxiosPromise<ToolsroamAddTodoPost200Response> {
            return localVarFp.toolsroamRecallPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a memory or piece of information to remember, stored on the daily page with #[[LLM/Memories]] tag and optional categories.  NOTE on Roam-flavored markdown: For direct linking: use [[link]] syntax. For aliased linking, use [alias]([[link]]) syntax. Do not concatenate words in links/hashtags - correct: #[[multiple words]] #self-esteem (for typically hyphenated words).
         * @param {ToolsroamRememberPostRequest} toolsroamRememberPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamRememberPost(toolsroamRememberPostRequest: ToolsroamRememberPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolsroamAddTodoPost200Response> {
            return localVarFp.toolsroamRememberPost(toolsroamRememberPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for block references within a page or across the entire graph. Can search for references to a specific block or find all block references.
         * @param {ToolsroamSearchBlockRefsPostRequest} toolsroamSearchBlockRefsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamSearchBlockRefsPost(toolsroamSearchBlockRefsPostRequest: ToolsroamSearchBlockRefsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolsroamAddTodoPost200Response> {
            return localVarFp.toolsroamSearchBlockRefsPost(toolsroamSearchBlockRefsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for blocks or pages based on creation or modification dates
         * @param {ToolsroamSearchByDatePostRequest} toolsroamSearchByDatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamSearchByDatePost(toolsroamSearchByDatePostRequest: ToolsroamSearchByDatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolsroamAddTodoPost200Response> {
            return localVarFp.toolsroamSearchByDatePost(toolsroamSearchByDatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for blocks with a specific status (TODO/DONE) across all pages or within a specific page.
         * @param {ToolsroamSearchByStatusPostRequest} toolsroamSearchByStatusPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamSearchByStatusPost(toolsroamSearchByStatusPostRequest: ToolsroamSearchByStatusPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolsroamAddTodoPost200Response> {
            return localVarFp.toolsroamSearchByStatusPost(toolsroamSearchByStatusPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for blocks containing specific text across all pages or within a specific page.
         * @param {ToolsroamSearchByTextPostRequest} toolsroamSearchByTextPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamSearchByTextPost(toolsroamSearchByTextPostRequest: ToolsroamSearchByTextPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolsroamAddTodoPost200Response> {
            return localVarFp.toolsroamSearchByTextPost(toolsroamSearchByTextPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for blocks containing a specific tag and optionally filter by blocks that also contain another tag nearby. Example: Use this to search for memories that are tagged with the MEMORIES_TAG.
         * @param {ToolsroamSearchForTagPostRequest} toolsroamSearchForTagPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamSearchForTagPost(toolsroamSearchForTagPostRequest: ToolsroamSearchForTagPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolsroamAddTodoPost200Response> {
            return localVarFp.toolsroamSearchForTagPost(toolsroamSearchForTagPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for parent or child blocks in the block hierarchy. Can search up or down the hierarchy from a given block.
         * @param {ToolsroamSearchHierarchyPostRequest | null} toolsroamSearchHierarchyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamSearchHierarchyPost(toolsroamSearchHierarchyPostRequest: ToolsroamSearchHierarchyPostRequest | null, options?: RawAxiosRequestConfig): AxiosPromise<ToolsroamAddTodoPost200Response> {
            return localVarFp.toolsroamSearchHierarchyPost(toolsroamSearchHierarchyPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the content of an existing block identified by its UID. Can either provide new content directly or use a transform pattern to modify existing content. NOTE on Roam-flavored markdown: For direct linking: use [[link]] syntax. For aliased linking, use [alias]([[link]]) syntax. Do not concatenate words in links/hashtags - correct: #[[multiple words]] #self-esteem (for typically hyphenated words).
         * @param {ToolsroamUpdateBlockPostRequest | null} toolsroamUpdateBlockPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamUpdateBlockPost(toolsroamUpdateBlockPostRequest: ToolsroamUpdateBlockPostRequest | null, options?: RawAxiosRequestConfig): AxiosPromise<ToolsroamAddTodoPost200Response> {
            return localVarFp.toolsroamUpdateBlockPost(toolsroamUpdateBlockPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update multiple blocks in a single batch operation. Each update can provide either new content directly or a transform pattern. NOTE on Roam-flavored markdown: For direct linking: use [[link]] syntax. For aliased linking, use [alias]([[link]]) syntax. Do not concatenate words in links/hashtags - correct: #[[multiple words]] #self-esteem (for typically hyphenated words).
         * @param {ToolsroamUpdateBlocksPostRequest} toolsroamUpdateBlocksPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolsroamUpdateBlocksPost(toolsroamUpdateBlocksPostRequest: ToolsroamUpdateBlocksPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolsroamAddTodoPost200Response> {
            return localVarFp.toolsroamUpdateBlocksPost(toolsroamUpdateBlocksPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary List all available tools
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public toolsGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).toolsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find all pages that have been modified today (since midnight).
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public toolsfindPagesModifiedTodayPost(body: object, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).toolsfindPagesModifiedTodayPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a list of todo items as individual blocks to today\'s daily page in Roam. Each item becomes its own actionable block with todo status. NOTE on Roam-flavored markdown: For direct linking: use [[link]] syntax. For aliased linking, use [alias]([[link]]) syntax. Do not concatenate words in links/hashtags - correct: #[[multiple words]] #self-esteem (for typically hyphenated words).
     * @param {ToolsroamAddTodoPostRequest} toolsroamAddTodoPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public toolsroamAddTodoPost(toolsroamAddTodoPostRequest: ToolsroamAddTodoPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).toolsroamAddTodoPost(toolsroamAddTodoPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new block to an existing Roam page. If no page specified, adds to today\'s daily note. Best for capturing immediate thoughts, additions to discussions, or content that doesn\'t warrant its own page. Can specify page by title or UID. NOTE on Roam-flavored markdown: For direct linking: use [[link]] syntax. For aliased linking, use [alias]([[link]]) syntax. Do not concatenate words in links/hashtags - correct: #[[multiple words]] #self-esteem (for typically hyphenated words).
     * @param {ToolsroamCreateBlockPostRequest} toolsroamCreateBlockPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public toolsroamCreateBlockPost(toolsroamCreateBlockPostRequest: ToolsroamCreateBlockPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).toolsroamCreateBlockPost(toolsroamCreateBlockPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a structured outline to an existing page or block (by title text or uid), with customizable nesting levels. Best for: - Adding supplementary structured content to existing pages - Creating temporary or working outlines (meeting notes, brainstorms) - Organizing thoughts or research under a specific topic - Breaking down subtopics or components of a larger concept
     * @param {ToolsroamCreateOutlinePostRequest} toolsroamCreateOutlinePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public toolsroamCreateOutlinePost(toolsroamCreateOutlinePostRequest: ToolsroamCreateOutlinePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).toolsroamCreateOutlinePost(toolsroamCreateOutlinePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new standalone page in Roam with optional content using markdown-style formatting. The nesting structure is inferred from markdown indentation (spaces). Best for: - Creating foundational concept pages that other pages will link to/from - Establishing new topic areas that need their own namespace - Setting up reference materials or documentation - Making permanent collections of information.
     * @param {ToolsroamCreatePagePostRequest} toolsroamCreatePagePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public toolsroamCreatePagePost(toolsroamCreatePagePostRequest: ToolsroamCreatePagePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).toolsroamCreatePagePost(toolsroamCreatePagePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Execute a custom Datomic query on the Roam graph beyond the available search tools. This provides direct access to Roam\'s query engine for advanced data retrieval. Note: Roam graph is case-sensitive. List of some of Roam\'s data model Namespaces and Attributes: ancestor (descendants), attrs (lookup), block (children, heading, open, order, page, parents, props, refs, string, text-align, uid), children (view-type), create (email, time), descendant (ancestors), edit (email, seen-by, time), entity (attrs), log (id), node (title), page (uid, title), refs (text). Predicates (clojure.string/includes?, clojure.string/starts-with?, clojure.string/ends-with?, <, >, <=, >=, =, not=, !=). Aggregates (distinct, count, sum, max, min, avg, limit). Tips: Use :block/parents for all ancestor levels, :block/children for direct descendants only; combine clojure.string for complex matching, use distinct to deduplicate, leverage Pull patterns for hierarchies, handle case-sensitivity carefully, and chain ancestry rules for multi-level queries.
     * @param {ToolsroamDatomicQueryPostRequest} toolsroamDatomicQueryPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public toolsroamDatomicQueryPost(toolsroamDatomicQueryPostRequest: ToolsroamDatomicQueryPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).toolsroamDatomicQueryPost(toolsroamDatomicQueryPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve complete page contents by exact title, including all nested blocks and resolved block references. Use for reading and analyzing existing Roam pages.
     * @param {ToolsroamFetchPageByTitlePostRequest} toolsroamFetchPageByTitlePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public toolsroamFetchPageByTitlePost(toolsroamFetchPageByTitlePostRequest: ToolsroamFetchPageByTitlePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).toolsroamFetchPageByTitlePost(toolsroamFetchPageByTitlePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import nested markdown content into Roam under a specific block. Can locate the parent block by UID or by exact string match within a specific page.
     * @param {ToolsroamImportMarkdownPostRequest} toolsroamImportMarkdownPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public toolsroamImportMarkdownPost(toolsroamImportMarkdownPostRequest: ToolsroamImportMarkdownPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).toolsroamImportMarkdownPost(toolsroamImportMarkdownPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve all stored memories by searching for blocks tagged with MEMORIES_TAG and content from the page with the same name. Returns a combined, deduplicated list of memories.
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public toolsroamRecallPost(body: object, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).toolsroamRecallPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a memory or piece of information to remember, stored on the daily page with #[[LLM/Memories]] tag and optional categories.  NOTE on Roam-flavored markdown: For direct linking: use [[link]] syntax. For aliased linking, use [alias]([[link]]) syntax. Do not concatenate words in links/hashtags - correct: #[[multiple words]] #self-esteem (for typically hyphenated words).
     * @param {ToolsroamRememberPostRequest} toolsroamRememberPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public toolsroamRememberPost(toolsroamRememberPostRequest: ToolsroamRememberPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).toolsroamRememberPost(toolsroamRememberPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for block references within a page or across the entire graph. Can search for references to a specific block or find all block references.
     * @param {ToolsroamSearchBlockRefsPostRequest} toolsroamSearchBlockRefsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public toolsroamSearchBlockRefsPost(toolsroamSearchBlockRefsPostRequest: ToolsroamSearchBlockRefsPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).toolsroamSearchBlockRefsPost(toolsroamSearchBlockRefsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for blocks or pages based on creation or modification dates
     * @param {ToolsroamSearchByDatePostRequest} toolsroamSearchByDatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public toolsroamSearchByDatePost(toolsroamSearchByDatePostRequest: ToolsroamSearchByDatePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).toolsroamSearchByDatePost(toolsroamSearchByDatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for blocks with a specific status (TODO/DONE) across all pages or within a specific page.
     * @param {ToolsroamSearchByStatusPostRequest} toolsroamSearchByStatusPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public toolsroamSearchByStatusPost(toolsroamSearchByStatusPostRequest: ToolsroamSearchByStatusPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).toolsroamSearchByStatusPost(toolsroamSearchByStatusPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for blocks containing specific text across all pages or within a specific page.
     * @param {ToolsroamSearchByTextPostRequest} toolsroamSearchByTextPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public toolsroamSearchByTextPost(toolsroamSearchByTextPostRequest: ToolsroamSearchByTextPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).toolsroamSearchByTextPost(toolsroamSearchByTextPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for blocks containing a specific tag and optionally filter by blocks that also contain another tag nearby. Example: Use this to search for memories that are tagged with the MEMORIES_TAG.
     * @param {ToolsroamSearchForTagPostRequest} toolsroamSearchForTagPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public toolsroamSearchForTagPost(toolsroamSearchForTagPostRequest: ToolsroamSearchForTagPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).toolsroamSearchForTagPost(toolsroamSearchForTagPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for parent or child blocks in the block hierarchy. Can search up or down the hierarchy from a given block.
     * @param {ToolsroamSearchHierarchyPostRequest | null} toolsroamSearchHierarchyPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public toolsroamSearchHierarchyPost(toolsroamSearchHierarchyPostRequest: ToolsroamSearchHierarchyPostRequest | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).toolsroamSearchHierarchyPost(toolsroamSearchHierarchyPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the content of an existing block identified by its UID. Can either provide new content directly or use a transform pattern to modify existing content. NOTE on Roam-flavored markdown: For direct linking: use [[link]] syntax. For aliased linking, use [alias]([[link]]) syntax. Do not concatenate words in links/hashtags - correct: #[[multiple words]] #self-esteem (for typically hyphenated words).
     * @param {ToolsroamUpdateBlockPostRequest | null} toolsroamUpdateBlockPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public toolsroamUpdateBlockPost(toolsroamUpdateBlockPostRequest: ToolsroamUpdateBlockPostRequest | null, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).toolsroamUpdateBlockPost(toolsroamUpdateBlockPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update multiple blocks in a single batch operation. Each update can provide either new content directly or a transform pattern. NOTE on Roam-flavored markdown: For direct linking: use [[link]] syntax. For aliased linking, use [alias]([[link]]) syntax. Do not concatenate words in links/hashtags - correct: #[[multiple words]] #self-esteem (for typically hyphenated words).
     * @param {ToolsroamUpdateBlocksPostRequest} toolsroamUpdateBlocksPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public toolsroamUpdateBlocksPost(toolsroamUpdateBlocksPostRequest: ToolsroamUpdateBlocksPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).toolsroamUpdateBlocksPost(toolsroamUpdateBlocksPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



